# 3D游戏渲染问题修复记录

## 问题描述

在执行3D游戏（横冲直撞.jar）时出现以下问题：
1. **texParameterf错误**：反复出现 `GL_INVALID_ENUM` 错误，导致纹理参数设置失败
2. **ArrayIndexOutOfBoundsException**：在渲染过程中出现数组越界异常
3. **渲染内容为黑色**：WebGL canvas像素值为 `0 0 0 0`，没有实际内容被渲染

## 修复内容

### 1. 修复 texParameterf 错误（已解决）

**问题**：在 `Emulator3D.java` 第806-811行，对纹理包装参数（`GL_TEXTURE_WRAP_S` 和 `GL_TEXTURE_WRAP_T`）使用了 `texParameterf`（float版本），但这些参数应该使用 `texParameteri`（整数版本），因为它们是枚举值。

**修复**：
- 文件：`javamake/javanew/kemulator/m3g/gles2/Emulator3D.java`
- 位置：第820-825行
- 修改：将 `texParameterf` 改为 `texParameteri`

```java
// 修复前
GLES2.texParameterf(GLES2.Constants.GL_TEXTURE_2D, GLES2.Constants.GL_TEXTURE_WRAP_S, ...);

// 修复后
GLES2.texParameteri(GLES2.Constants.GL_TEXTURE_2D, GLES2.Constants.GL_TEXTURE_WRAP_S, ...);
```

**结果**：texParameterf错误已消失 ✓

### 2. 改进 readPixels 错误处理

**问题**：`readPixels` 函数在读取像素数据时，如果buffer大小不够，会导致数组越界。

**修复**：
- 文件：`java/libs/libgles2.js`
- 位置：第656-677行
- 改进内容：
  - 添加buffer大小验证
  - 添加边界检查和错误日志
  - 添加异常处理

```javascript
Java_pl_zb3_freej2me_bridge_gles2_GLES2_readPixels: function(lib, ptr, x, y, width, height, int8pixels) {
  const gl = ptr.gl;
  try {
    const expectedSize = width * height * 4; // RGBA = 4 bytes per pixel
    const actualSize = int8pixels ? int8pixels.byteLength : 0;
    
    if (!int8pixels || actualSize < expectedSize) {
      console.warn('[GLES2] readPixels - buffer size mismatch. Expected:', expectedSize, 'Got:', actualSize);
      return;
    }
    // ... 执行readPixels
  } catch (e) {
    console.error('[GLES2] readPixels exception:', e);
  }
}
```

### 3. 改进 swapBuffers 错误处理

**问题**：在 `swapBuffers` 中可能出现数组越界，特别是在处理Image2D目标时。

**修复**：
- 文件：`javamake/javanew/kemulator/m3g/gles2/Emulator3D.java`
- 位置：第193-263行
- 改进内容：
  - 添加异常处理（try-catch）
  - 添加buffer大小检查和自动调整
  - 添加数组访问边界检查
  - 添加维度验证（width > 0, height > 0, x >= 0, y >= 0）
  - 在arraycopy前验证偏移量和长度

```java
// 添加维度验证
if (width <= 0 || height <= 0 || x < 0 || y < 0) {
    System.err.println("[Emulator3D] swapBuffers - invalid dimensions");
    return;
}

// 添加边界检查
if (srcOffset + rowSize <= buffer.length && dstOffset + rowSize <= flippedBuffer.length) {
    System.arraycopy(buffer, srcOffset, flippedBuffer, dstOffset, rowSize);
}
```

### 4. 改进 texImage2D 错误处理

**问题**：纹理数据上传时，如果buffer大小不匹配，可能导致问题。

**修复**：
- 文件：`java/libs/libgles2.js`
- 位置：第452-471行
- 改进内容：
  - 添加buffer大小验证（根据格式计算期望大小）
  - 添加格式检查和错误日志
  - 添加WebGL错误检查

```javascript
Java_pl_zb3_freej2me_bridge_gles2_GLES2_texImage2D: function(lib, ptr, target, level, intFormat, width, height, border, format, type, byteArray) {
  // 计算期望的数据大小
  let bytesPerPixel = 4; // Default to RGBA
  if (format === gl.RGB) bytesPerPixel = 3;
  else if (format === gl.LUMINANCE_ALPHA) bytesPerPixel = 2;
  else if (format === gl.LUMINANCE || format === gl.ALPHA) bytesPerPixel = 1;
  
  const expectedSize = width * height * bytesPerPixel;
  
  // 验证buffer大小
  if (byteArray.byteLength < expectedSize) {
    console.warn('[GLES2] texImage2D - buffer size mismatch');
  }
  // ... 执行texImage2D
}
```

## 游戏源码分析

通过JADX反编译工具查看了游戏源码（横冲直撞.jar）：

### 主要类结构
- **RMIDlet**：主MIDlet类，继承自MIDlet
- **e类**：主要的游戏逻辑类，继承自FullCanvas，实现Runnable
- **b类**：游戏状态管理类，包含3D渲染相关代码
- **g类**：游戏核心逻辑类，包含大量3D渲染和物理计算

### 3D渲染流程
游戏使用 `javax.microedition.m3g.Graphics3D` 进行3D渲染：

```java
// 在 g.m35a() 方法中
Graphics3D graphics3D = Graphics3D.getInstance();
graphics3D.bindTarget(f186b);
graphics3D.clear(f225a);
a(graphics3D);  // 设置相机和光照
c(graphics3D);  // 渲染背景
d(graphics3D);  // 渲染对象
e(graphics3D);  // 渲染特效
b(graphics3D);  // 渲染车辆
graphics3D.render(f281a.f3a, transform2);  // 渲染其他对象
graphics3D.releaseTarget();
```

## 仍需调查的问题

### 1. ArrayIndexOutOfBoundsException

**现象**：仍然出现 `java/lang/ArrayIndexOutOfBoundsException detailMessage: Invalid index.`

**可能原因**：
- 发生在 `Sys.copyArray` 中（`custom/org/mozilla/internal/Sys.java`）
- 可能是在复制数组数据时，源数组或目标数组的大小不匹配
- 可能发生在纹理数据复制、像素数据复制等操作中

**已做改进**：
- 在 `swapBuffers` 中添加了边界检查
- 在 `readPixels` 中添加了buffer大小验证
- 在 `texImage2D` 中添加了buffer大小验证

**建议**：
- 如果问题仍然存在，需要查看完整的堆栈跟踪来确定具体位置
- 检查是否有其他地方调用 `Sys.copyArray` 时没有进行边界检查

### 2. 渲染内容为黑色

**现象**：WebGL canvas像素值为 `0 0 0 0`（黑色），没有实际内容被渲染

**可能原因**：
1. **纹理未正确加载**：纹理数据可能为空或格式不正确
2. **着色器未正确设置**：着色器程序可能没有正确编译或链接
3. **渲染状态异常**：深度测试、混合模式等可能设置不正确
4. **相机/光照设置不正确**：相机位置或光照参数可能导致场景不可见
5. **顶点数据问题**：顶点缓冲区可能没有正确上传

**已做改进**：
- 改进了纹理加载的错误处理
- 添加了更详细的错误日志

**建议**：
- 检查WebGL控制台是否有其他错误信息
- 验证纹理是否正确加载（检查 `getImageData()` 返回的数据）
- 检查着色器编译是否成功
- 验证相机和光照参数是否正确设置

## 测试建议

1. **重新编译**：确保所有修改都已编译到最新的JavaScript文件中
2. **清除缓存**：清除浏览器缓存，确保加载最新版本的代码
3. **查看控制台**：关注以下日志：
   - `[GLES2] texImage2D` 相关的警告或错误
   - `[GLES2] readPixels` 相关的警告或错误
   - `[Emulator3D] swapBuffers` 相关的错误
   - WebGL错误信息
4. **检查渲染状态**：验证以下内容：
   - 纹理是否正确加载
   - 着色器是否编译成功
   - 相机和光照是否正确设置
   - 顶点数据是否正确上传

## 相关文件

### 修改的文件
1. `javamake/javanew/kemulator/m3g/gles2/Emulator3D.java`
   - 修复texParameterf错误
   - 改进swapBuffers错误处理

2. `java/libs/libgles2.js`
   - 改进readPixels错误处理
   - 改进texImage2D错误处理

### 相关文档
- `3D_INTEGRATION_STATUS.md`：3D集成状态
- `3D_INTEGRATION_PLAN.md`：3D集成计划
- `COMPILE_INSTRUCTIONS.md`：编译说明

## 修复日期

2025年12月12日

## 最新修复（2025年12月12日更新）

### 5. 修复 releaseTarget 和 swapBuffers 的卡住问题

**问题**：
- `releaseTarget()` 中即使 `GLES2.bound` 为 false 也会调用 `swapBuffers()`，可能导致在没有活跃上下文时尝试读取像素或复制内容
- `finish()` 可能没有被正确调用，导致渲染未完成就被复制
- `swapBuffers()` 中调用 `readPixels` 或 `blitGL` 时没有检查上下文是否可用

**修复**：
- 文件：`javamake/javanew/kemulator/m3g/gles2/Emulator3D.java`
- 位置：第167-187行（releaseTarget）、第219-230行（swapBuffers readPixels）、第268-281行（swapBuffers blitGL）
- 修改内容：
  1. 改进 `releaseTarget()` 逻辑：始终尝试完成渲染和交换缓冲区，但添加了异常处理
  2. 在 `readPixels` 调用前检查 `GLES2.getCanvasRef()` 是否可用
  3. 在 `blitGL` 调用前检查 `GLES2.getCanvasRef()` 是否可用
  4. 添加更详细的错误日志

### 6. 改进 libgles2.js 中的错误处理

**问题**：
- `clear()`、`viewport()`、`finish()`、`readPixels()` 等方法没有检查 `ptr` 或 `gl` 是否为 null
- 可能导致在上下文未正确初始化时崩溃

**修复**：
- 文件：`java/libs/libgles2.js`
- 位置：第570-577行（clear）、第708-715行（viewport）、第671-681行（finish）、第681-702行（readPixels）
- 修改内容：
  1. 在所有关键方法中添加 `ptr` 和 `gl` 的空值检查
  2. 添加 try-catch 异常处理
  3. 改进错误日志输出
  4. 在 `readPixels` 中添加坐标边界检查

### 7. 修复显示上一帧画面的问题（关键修复）

**问题**：
- 游戏画面显示的是上一帧的内容，而不是最新渲染的帧
- 在 `swapBuffers` 调用 `blitGL` 复制 WebGL 画布内容到 2D Canvas 时，WebGL 渲染命令可能还没有执行完成
- 导致复制的是旧的渲染内容

**修复**：
- 文件：`javamake/javanew/kemulator/m3g/gles2/Emulator3D.java`
- 位置：第296-310行（swapBuffers CanvasGraphics 分支）
- 修改内容：
  1. 在调用 `blitGL` 之前，先调用 `GLES2.finish()` 确保所有 WebGL 渲染命令都已完成执行
  2. 这确保读取 WebGL 画布内容时，获取的是最新渲染的帧，而不是上一帧

```java
// 在 swapBuffers 的 CanvasGraphics 分支中
if (GLES2.getCanvasRef() != null) {
    // CRITICAL: Ensure all rendering commands are completed before reading from WebGL canvas
    // This ensures we get the latest rendered frame, not the previous one
    if (GLES2.bound) {
        GLES2.finish();
    }
    ((CanvasGraphics) this.target).blitGL(x, y, x, y, width, height, true, false);
}
```

**结果**：修复后应该显示最新渲染的帧，而不是上一帧 ✓

### 8. 修复透明背景导致画面全黑的问题

**问题**：
- `clearColor` 被设置为 `0 0 0 0`（完全透明的黑色）
- 当背景颜色为 0 时，`G3DUtils.getFloatColor(0, 24)` 返回的 alpha 值为 0，导致背景完全透明
- 透明背景在 WebGL 中会导致看不到任何内容

**修复**：
- 文件：`javamake/javanew/kemulator/m3g/gles2/Emulator3D.java`
- 位置：第376-391行（clearBackgound 方法）
- 修改内容：
  1. 检查如果 `bgColor` 为 0 且 `a` 为 0.0 时，将 alpha 强制设置为 1.0（完全不透明）
  2. 这确保即使是黑色背景，也会以不透明的方式清除，而不是透明的

```java
float a = G3DUtils.getFloatColor(bgColor, 24);
// Ensure alpha is at least 1.0 (fully opaque) if color is 0 (black)
// This prevents clearing to fully transparent black which would show nothing
if (bgColor == 0 && a == 0.0f) {
    a = 1.0f; // Default to opaque black instead of transparent
}
```

**结果**：背景不再透明，可以正常看到渲染内容 ✓

### 9. 减少控制台日志刷屏问题

**问题**：
- 控制台不断输出大量日志，包括 `clear`、`viewport`、`clearColor`、`swapBuffers`、`blitGL` 等的调用信息
- 导致控制台刷屏，难以查看真正的错误信息
- 可能影响性能

**修复**：
- 文件：
  1. `javamake/javanew/kemulator/m3g/gles2/Emulator3D.java` - 第28-29行、第199-210行、第296-310行、第378-388行
  2. `java/libs/libgles2.js` - 第570-577行、第579-582行、第708-715行
  3. `java/libs/libcanvasgraphics.js` - 第527-533行、第587-603行
- 修改内容：
  1. 在 Java 代码中添加日志节流机制（每秒最多输出一次日志）
  2. 在 JavaScript 代码中，只在 `DEBUG` 模式下或随机 1% 的调用时输出日志
  3. 对于频繁调用的方法（如 `clear`、`viewport`、`blitGL`），大幅减少日志输出

**结果**：
- 控制台日志输出大幅减少，不再刷屏 ✓
- 重要的错误信息仍然会被记录
- 可以通过设置 `DEBUG = true` 来启用详细日志

### 10. 改进 Image2D.set() 的数组大小验证和错误处理

**问题**：
- 在 `swapBuffers` 中调用 `Image2D.set()` 时，传入的数组大小可能与期望的不匹配
- 如果 `Image2D.set()` 抛出异常，可能导致 `releaseTarget()` 失败，进而导致 target 没有被正确释放

**修复**：
- 文件：`javamake/javanew/kemulator/m3g/gles2/Emulator3D.java`
- 位置：第249-313行（swapBuffers Image2D 分支）
- 修改内容：
  1. 使用 `targetImage.getBitsPerColor()` 计算正确的数组大小
  2. 在调用 `Image2D.set()` 前验证数组大小
  3. 添加 try-catch 异常处理，确保即使 `set()` 失败也不会中断流程
  4. 改进了 RGB 格式转换，支持不同的 bitsPerColor 值

### 11. 改进 releaseTarget() 的异常处理和资源清理

**问题**：
- 如果 `finish()` 或 `swapBuffers()` 抛出异常，可能导致 `target` 没有被正确清除
- 导致 `Graphics3D.target` 一直不为 null，每次 `bindTarget()` 都需要 auto-release
- 异常可能导致资源泄漏

**修复**：
- 文件：
  1. `javamake/javanew/kemulator/m3g/gles2/Emulator3D.java` - 第171-204行
  2. `javamake/javanew/midp/javax/microedition/m3g/Graphics3D.java` - 第190-206行
- 修改内容：
  1. 在 `releaseTarget()` 中添加多层异常处理
  2. 确保即使 `finish()` 或 `swapBuffers()` 失败，`target` 也会被清除
  3. 在 `Graphics3D.releaseTarget()` 中也添加异常处理
  4. 确保 `target` 和 `originalGraphicsTarget` 在异常情况下也会被清除

**结果**：
- 即使出现异常，资源也能被正确清理 ✓
- 减少 `Graphics3D` 的 auto-release 警告 ✓
- 提高代码的健壮性 ✓

## 当前状态

根据最新的日志分析：

### 已解决的问题 ✓
1. **背景透明问题**：WebGL canvas 像素现在是 `0 0 0 255`（不透明黑色），而不是 `0 0 0 0`
2. **渲染命令执行**：可以看到 `drawArrays` 和 `drawElements` 正在正常调用
3. **日志刷屏**：日志输出已大幅减少

### 仍存在的问题

1. **ArrayIndexOutOfBoundsException**
   - **现象**：仍然出现 `java/lang/ArrayIndexOutOfBoundsException detailMessage: Invalid index.`
   - **可能位置**：可能发生在 `Image2D.set()` 内部，或 `Sys.copyArray` 调用中
   - **已做改进**：
     - 在 `swapBuffers` 中添加了数组大小验证
     - 添加了 try-catch 异常处理
     - 使用 `getBitsPerColor()` 确保数组大小正确
   - **建议**：需要查看完整的异常堆栈跟踪来定位具体位置

2. **游戏卡住问题**
   - **现象**：游戏在某个点卡住，可能是异常导致线程阻塞
   - **可能原因**：
     - `ArrayIndexOutOfBoundsException` 没有被正确捕获，导致线程挂起
     - 某个同步操作导致死锁
     - 渲染循环中的等待操作
   - **已做改进**：
     - 改进了 `releaseTarget()` 的异常处理，确保不会因为异常导致资源泄漏
     - 添加了多层异常保护

3. **releaseTarget 警告**
   - **现象**：`[Graphics3D] Warning: Previous target not released, auto-releasing`
   - **可能原因**：`releaseTarget()` 可能因为异常没有被调用，或者 `target` 清除失败
   - **已做改进**：
     - 在 `Graphics3D.releaseTarget()` 中添加了异常处理
     - 确保即使在异常情况下 `target` 也会被清除

## 备注

- 所有修复都添加了详细的错误日志，便于后续调试
- 建议在测试时关注控制台输出，特别是警告和错误信息
- 如果问题仍然存在，请提供完整的错误堆栈跟踪和WebGL错误信息
- **重要**：修复后需要重新编译Java代码并刷新浏览器缓存

