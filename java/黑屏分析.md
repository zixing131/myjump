# 3D游戏黑屏问题分析

## 问题概述

**当前状态**：3D游戏（如横冲直撞.jar）不再卡死，但出现黑屏问题，画面完全为黑色，无法看到游戏内容。

**影响**：游戏可以运行，但无法看到渲染内容，用户体验严重受损。

**分析日期**：2025年12月12日

## 已修复的黑屏相关问题回顾

根据 `记录.md`，之前已经修复了多个导致黑屏的问题：

### 1. 着色器相关问题 ✅

#### 1.1 聚光灯计算bug（修复12）
- **问题**：顶点着色器中聚光灯计算被调试代码跳过
- **修复**：移除了错误的 `return` 语句
- **文件**：`mesh_vertex.glsl`

#### 1.2 材质Alpha值为0（修复13）
- **问题**：Material 颜色的 alpha 值为 0，导致透明
- **修复**：如果 alpha 为 0，强制设置为 1.0
- **文件**：`Emulator3D.java` 的 `setupMaterial` 方法

#### 1.3 MODULATE模式+黑色顶点颜色（修复14）
- **问题**：MODULATE 模式下，黑色顶点颜色乘以纹理颜色 = 黑色输出
- **修复**：如果顶点颜色是黑色，强制设置为白色
- **文件**：`mesh_fragment.glsl`

#### 1.4 光照计算返回黑色（修复16）
- **问题**：光照计算返回黑色或非常暗的颜色
- **修复**：如果光照计算返回的颜色太暗，使用材质 diffuse 颜色作为后备
- **文件**：`mesh_vertex.glsl`

### 2. Canvas渲染流程问题 ✅

#### 2.1 Canvas不一致问题（修复22）
- **问题**：`drawImage2` 写入 offscreen canvas，但被 2D UI 覆盖
- **修复**：3D 直接写入 device canvas，设置 `gles2JustRendered` 标志
- **文件**：`libcanvasgraphics.js`、`main-all.js`

#### 2.2 宽高参数为0（修复22）
- **问题**：`swapBuffers` 调用时 `targetWidth/targetHeight` 为 0，导致 `blitGL` 被跳过
- **修复**：当 w/h 为 0 时，使用 sourceCanvas 的尺寸
- **文件**：`libcanvasgraphics.js`

#### 2.3 getRGBAFromCtx 返回空（修复22）
- **问题**：当 `ctxHandle` 为 0 时返回空数组
- **修复**：使用 deviceContext 作为 fallback
- **文件**：`libcanvasgraphics.js`

### 3. 背景透明问题 ✅

#### 3.1 透明背景导致全黑（修复8）
- **问题**：`clearColor` 被设置为 `0 0 0 0`（完全透明的黑色）
- **修复**：如果 `bgColor` 为 0 且 alpha 为 0，强制设置为 1.0
- **文件**：`Emulator3D.java` 的 `clearBackgound` 方法

### 4. 显示上一帧画面问题 ✅

#### 4.1 显示上一帧内容（修复7）
- **问题**：WebGL 渲染命令未完成就复制内容
- **修复**：在 `blitGL` 前调用 `GLES2.finish()` 确保渲染完成
- **文件**：`Emulator3D.java` 的 `swapBuffers` 方法

## 当前黑屏问题的可能原因

基于已修复的问题和当前状态，黑屏问题可能由以下原因导致：

### 1. 渲染流程中断 ⚠️

**可能原因**：
- `gles2JustRendered` 标志可能没有正确设置或清除
- `refresh0` 可能没有正确检测到标志，仍然复制了 offscreen canvas（覆盖了 3D 内容）
- `drawImage2` 可能没有正确写入 device canvas

**诊断方法**：
```javascript
// 在浏览器控制台检查
console.log('gles2JustRendered:', window.gles2JustRendered);
console.log('deviceContext:', window.MIDP?.deviceContext);
```

### 2. WebGL渲染未执行 ⚠️

**可能原因**：
- WebGL 上下文可能丢失或未正确初始化
- `bindTarget` 可能没有被调用
- `clear` 可能清除了所有内容，但没有后续的渲染命令
- `drawElements` 或 `drawArrays` 可能没有被调用

**诊断方法**：
- 检查控制台是否有 WebGL 错误
- 检查是否有 `drawElements` 或 `drawArrays` 的调用日志
- 检查 WebGL 上下文状态

### 3. 像素数据读取失败 ⚠️

**可能原因**：
- `readPixels` 可能返回空数据或全0数据
- `putImageData` 可能没有正确写入 device canvas
- 像素格式转换可能出错

**诊断方法**：
- 在 `swapBuffers` 中检查读取的像素数据
- 检查 `putImageData` 是否被调用
- 检查像素数据是否全为0

### 4. 视口或裁剪区域问题 ⚠️

**可能原因**：
- 视口可能设置为 0x0 或无效值
- 裁剪区域可能不正确
- 渲染区域可能被裁剪到屏幕外

**诊断方法**：
- 检查 `viewport` 调用的参数
- 检查 `scissor` 设置
- 检查渲染目标的尺寸

### 5. 着色器编译或链接失败 ⚠️

**可能原因**：
- 着色器可能编译失败但没有报错
- 着色器程序可能链接失败
- Uniform 变量可能没有正确设置

**诊断方法**：
- 检查 WebGL 着色器编译错误
- 检查着色器程序链接状态
- 检查 uniform 变量是否正确设置

### 6. 纹理或材质数据问题 ⚠️

**可能原因**：
- 纹理可能没有正确加载
- 材质数据可能全为0（黑色）
- 纹理采样可能失败

**诊断方法**：
- 检查纹理加载日志
- 检查材质颜色值
- 检查纹理绑定状态

### 7. 深度测试或混合模式问题 ⚠️

**可能原因**：
- 深度测试可能过于严格，所有片段被丢弃
- 混合模式可能导致输出为黑色
- 颜色掩码可能禁用了所有颜色通道

**诊断方法**：
- 检查深度测试设置
- 检查混合模式设置
- 检查颜色掩码设置

## 诊断步骤

### 步骤1：检查渲染流程

1. **检查 `gles2JustRendered` 标志**：
   ```javascript
   // 在浏览器控制台
   console.log('gles2JustRendered:', window.gles2JustRendered);
   ```

2. **检查 device canvas 内容**：
   ```javascript
   const canvas = document.querySelector('canvas');
   const ctx = canvas.getContext('2d');
   const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
   console.log('Center pixel:', imageData.data.slice(
     (canvas.height/2 * canvas.width + canvas.width/2) * 4,
     (canvas.height/2 * canvas.width + canvas.width/2) * 4 + 4
   ));
   ```

3. **检查 WebGL canvas 内容**：
   ```javascript
   // 需要找到 WebGL canvas（可能在隐藏的 canvas 中）
   const glCanvas = document.querySelector('canvas[data-gles2]');
   if (glCanvas) {
     const gl = glCanvas.getContext('webgl2');
     const pixels = new Uint8Array(glCanvas.width * glCanvas.height * 4);
     gl.readPixels(0, 0, glCanvas.width, glCanvas.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
     console.log('WebGL center pixel:', pixels.slice(
       (glCanvas.height/2 * glCanvas.width + glCanvas.width/2) * 4,
       (glCanvas.height/2 * glCanvas.width + glCanvas.width/2) * 4 + 4
     ));
   }
   ```

### 步骤2：检查 WebGL 状态

1. **检查 WebGL 上下文**：
   ```javascript
   // 在 libgles2.js 中添加日志
   console.log('WebGL context:', ptr?.gl);
   console.log('WebGL context lost:', ptr?.gl?.isContextLost());
   ```

2. **检查渲染调用**：
   - 查看控制台是否有 `drawElements` 或 `drawArrays` 的调用日志
   - 检查调用次数和顶点数量

3. **检查 WebGL 错误**：
   ```javascript
   // 在关键位置添加
   const error = gl.getError();
   if (error !== gl.NO_ERROR) {
     console.error('WebGL error:', error);
   }
   ```

### 步骤3：检查着色器

1. **检查着色器编译状态**：
   - 查看控制台是否有着色器编译错误
   - 检查着色器源码是否正确加载

2. **检查着色器程序链接状态**：
   - 检查 `gl.getProgramParameter(program, gl.LINK_STATUS)`
   - 检查 `gl.getProgramInfoLog(program)`

3. **检查 Uniform 变量**：
   - 检查关键 uniform 变量是否正确设置（如 MVP 矩阵、纹理单元等）

### 步骤4：检查像素数据

1. **在 `swapBuffers` 中添加诊断**：
   ```java
   // 在 Emulator3D.java 的 swapBuffers 方法中
   // 读取中心像素
   int centerX = width / 2;
   int centerY = height / 2;
   int pixelIndex = (centerY * width + centerX) * 4;
   if (pixelIndex + 3 < buffer.length) {
       int r = buffer[pixelIndex] & 0xFF;
       int g = buffer[pixelIndex + 1] & 0xFF;
       int b = buffer[pixelIndex + 2] & 0xFF;
       int a = buffer[pixelIndex + 3] & 0xFF;
       System.out.println("[swapBuffers] Center pixel: R=" + r + " G=" + g + " B=" + b + " A=" + a);
   }
   ```

2. **检查 `putImageData` 调用**：
   - 在 `libcanvasgraphics.js` 的 `drawImage2` 中添加日志
   - 检查 `putImageData` 是否被调用，参数是否正确

### 步骤5：检查视口和裁剪

1. **检查视口设置**：
   - 查看 `viewport` 调用的日志
   - 确认视口覆盖整个渲染区域

2. **检查裁剪区域**：
   - 检查 `scissor` 设置
   - 确认裁剪区域不会裁剪掉所有内容

## 下一步建议

### 1. 添加详细诊断日志

在以下关键位置添加诊断日志：

1. **`Emulator3D.java` - `swapBuffers` 方法**：
   - 记录读取的像素数据（中心像素）
   - 记录 `targetWidth` 和 `targetHeight`
   - 记录 `blitGL` 是否被调用

2. **`libcanvasgraphics.js` - `drawImage2` 方法**：
   - 记录是否写入 device canvas
   - 记录 `gles2JustRendered` 标志的设置
   - 记录 `putImageData` 的参数

3. **`main-all.js` - `refresh0` 方法**：
   - 记录 `gles2JustRendered` 标志的检查结果
   - 记录是否跳过了复制

### 2. 检查 WebGL 渲染状态

1. **验证 WebGL 上下文**：
   - 检查上下文是否丢失
   - 检查上下文是否被正确初始化

2. **验证渲染调用**：
   - 确认 `drawElements` 或 `drawArrays` 被调用
   - 确认调用的顶点数量不为0

3. **验证着色器**：
   - 检查着色器编译和链接状态
   - 检查关键 uniform 变量的值

### 3. 检查像素数据流

1. **验证 `readPixels`**：
   - 检查读取的像素数据是否全为0
   - 检查像素数据格式是否正确

2. **验证 `putImageData`**：
   - 检查是否被调用
   - 检查写入的数据是否正确

3. **验证 Canvas 状态**：
   - 检查 device canvas 的内容
   - 检查 offscreen canvas 的内容

### 4. 临时调试方案

如果问题仍然存在，可以尝试以下临时调试方案：

1. **强制输出测试颜色**：
   ```glsl
   // 在片段着色器中临时添加
   void main() {
       gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // 强制输出红色
   }
   ```
   如果屏幕显示红色，说明渲染流程正常，问题在着色器逻辑。

2. **禁用所有特效**：
   - 临时禁用光照计算
   - 临时禁用纹理采样
   - 只使用简单的顶点颜色

3. **简化渲染流程**：
   - 只渲染一个简单的三角形
   - 验证基本的渲染流程是否正常

## 相关文件

### 关键文件
1. **`javamake/javanew/kemulator/m3g/gles2/Emulator3D.java`**
   - `swapBuffers` 方法：负责将 WebGL 内容复制到 Canvas
   - `bindTarget` 方法：初始化渲染目标
   - `clearBackgound` 方法：清除背景

2. **`java/libs/libcanvasgraphics.js`**
   - `drawImage2` 方法：将 WebGL 内容绘制到 Canvas
   - `getRGBAFromCtx` 方法：读取 Canvas 像素数据

3. **`java/bld/main-all.js`**
   - `refresh0` 方法：刷新屏幕内容

4. **着色器文件**：
   - `java/resources/m3g_shaders/mesh_vertex.glsl`
   - `java/resources/m3g_shaders/mesh_fragment.glsl`
   - `javamake/javanew/kemulator/m3g/gles2/m3g_shaders/mesh_vertex.glsl`
   - `javamake/javanew/kemulator/m3g/gles2/m3g_shaders/mesh_fragment.glsl`

### 参考文档
- `记录.md`：详细的修复记录
- `3D游戏卡死原因分析.md`：卡死问题的分析

## 总结

当前黑屏问题可能由多个原因导致，需要系统性地诊断：

1. **优先检查渲染流程**：确认 `gles2JustRendered` 标志和 Canvas 写入流程
2. **检查 WebGL 状态**：确认渲染命令是否执行
3. **检查像素数据**：确认数据是否正确读取和写入
4. **检查着色器**：确认着色器是否正确编译和链接

建议按照诊断步骤逐步排查，添加详细的诊断日志，定位具体的问题点。

---

**分析日期**：2025年12月12日  
**分析依据**：`记录.md`、`3D游戏卡死原因分析.md` 和当前代码状态
